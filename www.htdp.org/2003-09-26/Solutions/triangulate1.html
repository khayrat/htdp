<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Exercise 27.5.4; How to Design Programs </title>
</head>
<body>
<a href="../Book/curriculum-Z-H-34.html#node_thm_27.5.4">Problem Statement</a>
<pre>
#| ------------------------------------------------------------------------
   Data Definitions:

   A matrix is a list of list of numbers:
      (listof (listof num))
   such that all lists have the same length: 
   and each list contains at least two items. 

   A tri-matrix is a list of list of numbers:
      (listof (listof num))
   such that the 2nd is one shorter than the 1st, etc.
   Each list contains at least two items. 

   gauss : matrix -&gt; tri-matrix
   (define (gauss mat) ...)

   Purpose: Gaussian elimination for n x m matrix

   ASSUMPTION: no pivot is ever 0!

   Example: 
   (gauss (list (list 2 2  3 10) 
		(list 2 5 12 31)  
		(list 4 1 -2  1)))
   = 
   (list (list 2 2  3   10) 
	 (list   3  9   21)  
	 (list      1    2))   
|#

;; first draft
(define (gauss mat)
  (cond
    ((empty? mat) empty)
    (else (local ((define row1 (first mat)))
	    (cons row1 (gauss (subtract-row1-from-all-rows row1 (rest mat))))))))

#| ------------------------------------------------------------------------
   subtract-row1-from-all-rows :  (listof num) matrix -&gt; matrix
   (define (subtract-row1-from-all-rows row1 other-rows) ...)   

   Purpose: subtract enough multiples of row1 from all rows in other-rows
     so that first number of each new one is 0. Eliminate the 0, i.e., 
     all rows in result are one shorter than row1

   Example: 
    (subtract-row1-from-all-rows (list 2 3 4)
				 (list (list 2 3 4)
				       (list 4 4 4)))
    = 
    (list 
     (list  0  0)
     (list -2 -4))
|#

(define (subtract-row1-from-all-rows row1 mat)
  (map (subtract row1) mat))

#| ------------------------------------------------------------------------
   subtract : (list number) -&gt; ((list number) -&gt; (list number))
   (define (subtract row1) ...)
   
   Purpose: subtract enough multiples of row1 from row2 so that first 
     number is 0 chop off the 0; the result is one shorter than the two inputs

   Examples: 
     ((subtract (list 2 3 4)) (list 2 3 4))
     = 
     (list 0 0)
     
     ((subtract (list 2 3 4)) (list 4 4 4))
     =
     (list -2 -4)
|#

(define (subtract row1)
  (lambda (row2)
    (local ((define factor (/ (first row2) (first row1))))
      (rest (map - row2 (map (curry* factor) row1))))))

;; curry* : num -&gt; (num -&gt; num)
;; Purpose: a curried version of * 
(define (curry* n) (lambda (m) (* n m)))

#| Tests:

;; for subtract: 
(equal? 
 ((subtract (list 2 3 4)) (list 2 3 4))
 (list 0 0))

(equal? 
 ((subtract (list 2 3 4)) (list 4 4 4))
 (list -2 -4))

;; for subtract-row1-from-all-rows: 
(equal? 
 (subtract-row1-from-all-rows (list 2 3 4)
			      (list (list 2 3 4)
				    (list 4 4 4)))
 (list 
  (list  0  0)
  (list -2 -4)))

;; for gauss: 
(equal? 
 (gauss (list (list 2 2  3 10) 
	      (list 2 5 12 31)  
	      (list 4 1 -2  1)))
 (list (list 2 2  3   10) 
       (list   3  9   21)  
       (list      1    2)))
|#
</pre>
</body>
</html>
